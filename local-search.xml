<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>space-between与space-aroud的区别</title>
    <link href="/2021/05/12/justify-content/"/>
    <url>/2021/05/12/justify-content/</url>
    
    <content type="html"><![CDATA[<h2 id="space-between-与-space-around-的区别">space-between 与 space-around 的区别</h2><p>flex 布局 justify-content 属性值区别</p><p>space-between 最左、最右 item 贴合左侧或右侧边框，item 与 item 之间间距相等。<br>space-around 每个 item 左右方向的 margin 相等。两个 item 中间的间距会比较大</p><p><img src="/img/justify-content.png" alt=""></p><p>align-items:center; 垂直居中~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vuex之namespaced的使用</title>
    <link href="/2021/05/03/Vuex%E4%B9%8Bnamespaced/"/>
    <url>/2021/05/03/Vuex%E4%B9%8Bnamespaced/</url>
    
    <content type="html"><![CDATA[<h1>Vuex报错 unknown mutation type</h1><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的，这样使得多个模块能够对同一 mutation 或 action 作出响应，使用this.$store.commit(‘mutation’)触发mutation</p><p>如果要使用this.$store.commit(‘模块名称/mutation’)的方式触发mutation，可以通过添加 namespaced: true到export default 的方式使其成为带命名空间的模块。</p>]]></content>
    
    
    <categories>
      
      <category>踩过的坑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Less学习笔记</title>
    <link href="/2021/03/03/LESS/"/>
    <url>/2021/03/03/LESS/</url>
    
    <content type="html"><![CDATA[<h2 id="Less">Less</h2><p><img src="/img/image-20210303154609375.png" alt="image-20210303154609375"></p><h2 id="变量">变量</h2><p><img src="/img/image-20210303155051623.png" alt="image-20210303155051623"></p><h2 id="嵌套">嵌套</h2><p><img src="/img/image-20210303161254001.png" alt="image-20210303161254001"></p><p><img src="/img/image-20210303161717735.png" alt="image-20210303161717735"></p><p><img src="/img/image-20210303161801926.png" alt="image-20210303161801926"></p><h2 id="less-运算：-运算符左右两侧必须空格隔开">less 运算： 运算符左右两侧必须空格隔开</h2><p><img src="/img/image-20210303164545298.png" alt="image-20210303164545298"></p><h3 id="单位">单位</h3><p><img src="/img/image-20210303164957574.png" alt="image-20210303164957574"></p><h2 id="less-编译">less 编译</h2><p><img src="/img/image-20210303155525127.png" alt="image-20210303155525127"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="/2021/01/18/vue/"/>
    <url>/2021/01/18/vue/</url>
    
    <content type="html"><![CDATA[<h1>MVVM</h1><p><img src="/img/image-20210322152420803.png" alt="image-20210322152420803"></p><p><img src="/img/image-20210322160638153.png" alt="image-20210322160638153"></p><h1>模板语法</h1><h2 id="常用指令">常用指令</h2><p><img src="/img/image-20210323114449352.png" alt="image-20210323114449352"></p><h2 id="v-text-和-v-html">v-text 和 v-html</h2><p><img src="/img/image-20210323114912751.png" alt="image-20210323114912751"></p><p><img src="/img/image-20210323114935009.png" alt="image-20210323114935009"></p><h2 id="v-cloak-防止闪现：利用模板指令解析后不存在的特性">v-cloak 防止闪现：利用模板指令解析后不存在的特性</h2><p><img src="/img/image-20210327145656098.png" alt="image-20210327145656098"></p><h2 id="自定义指令">自定义指令</h2><p>​ el：指令属性所在的标签对象</p><p>​ binding：包含指令相关信息数据的对象</p><p>​ 局部指令只在定义的 vm 中有效</p><p><img src="/img/image-20210327160200376.png" alt="image-20210327160200376"></p><h1>计算属性</h1><h2 id="总结：computed-适合一个数据被多个数据影响，watch-适合一个数据影响多个数据">总结：computed 适合一个数据被多个数据影响，watch 适合一个数据影响多个数据</h2><p>​ 计算属性（computed）：</p><p><img src="/img/image-20210125105621286.png" alt="image-20210125105621286"></p><p><img src="/img/image-20210125111427569.png" alt="image-20210125111427569"></p><p>​ 侦听器 watch:</p><p><img src="/img/image-20210125113833716.png" alt="image-20210125113833716"></p><p><img src="/img/image-20210125115055227.png" alt="image-20210125115055227"></p><p><img src="/img/image-20210125115746303.png" alt="image-20210125115746303"></p><h1>class 与 style 的绑定</h1><p><img src="/img/image-20210323152007918.png" alt="image-20210323152007918"></p><p>​ 绑定 class：</p><p><img src="/img/image-20210323231147027.png" alt="image-20210323231147027"></p><p>​ 绑定 style：</p><p><img src="/img/image-20210125135655229.png" alt="image-20210125135655229"></p><h1>条件渲染 if 和 show：</h1><p><img src="/img/image-20210125144859816.png" alt="image-20210125144859816"></p><h3 id="key：在数据中加入-ID-或者-shortid-插件">key：在数据中加入 ID 或者 shortid 插件</h3><h1>列表渲染</h1><p><img src="/img/image-20210324113947445.png" alt="image-20210324113947445"></p><p><img src="/img/image-20210324114016907.png" alt="image-20210324114016907"></p><p>​ vue 重写了以下方法，使数组内部改变时会渲染到界面</p><p><img src="/img/image-20210324105328154.png" alt="image-20210324105328154"></p><h1>列表搜索过滤：计算属性</h1><p>​ .filter（）返回满足条件的结果</p><p><img src="/img/image-20210324120354961.png" alt="image-20210324120354961"></p><h1>列表排序：计算属性</h1><p>​ .sort(A,B){}</p><p><img src="/img/image-20210324122111599.png" alt="image-20210324122111599"></p><h1>事件处理</h1><h2 id="绑定监听">绑定监听</h2><p>​ 事件参数$event，没有传递参数时会默认传递这个$event，当有传参时要手动传递$event</p><p><img src="/img/image-20210324153303113.png" alt="image-20210324153303113"></p><h2 id="事件修饰符">事件修饰符</h2><p><img src="/img/image-20210324161018283.png" alt="image-20210324161018283"></p><h3 id="事件冒泡-stop-阻止事件冒泡">事件冒泡 .stop 阻止事件冒泡</h3><p><img src="/img/image-20210324160143883.png" alt="image-20210324160143883"></p><h3 id="默认事件-prevent-阻止默认行为">默认事件 .prevent 阻止默认行为</h3><h2 id="按键修饰符">按键修饰符</h2><p><img src="/img/image-20210324161102248.png" alt="image-20210324161102248"></p><p>​</p><p><img src="/img/image-20210324160853801.png" alt="image-20210324160853801"></p><h1>Vue 生命周期</h1><p>​ 最常用的两个生命周期回调函数（勾子）</p><p><img src="/img/image-20210327101421260.png" alt="image-20210327101421260"></p><h1>过滤器</h1><p>​ 对数据进行处理</p><p><img src="/img/image-20210327144757588.png" alt="image-20210327144757588"></p><p><img src="/img/image-20210327144820567.png" alt="image-20210327144820567"></p><h1>Vue-cli 创建项目</h1><p>​ vue init webpack demo 初始化项目，这里的 webpack 是模板名称</p><h2 id="打包，发布项目">打包，发布项目</h2><p>​ 静态服务器</p><p><img src="/img/image-20210330094346785.png" alt="image-20210330094346785"></p><p>动态服务器 需要下载 tomcat 到本地</p><p><img src="/img/image-20210330094507849.png" alt="image-20210330094507849"></p><h1>localStorage</h1><p>​ 存储数据，需要深度监视！</p><p>​ 以下配置在 data 中</p><p><img src="/img/image-20210428153442872.png" alt="image-20210428153442872"></p><h1>组件间通信</h1><h2 id="props，父往子">props，父往子</h2><p>​ 父组件传递</p><p><img src="/img/image-20210330110946173.png" alt="image-20210330110946173"></p><p>​ 子组件接收，接受到的属性可以和 data 里的数据一样使用</p><p><img src="/img/image-20210330111035917.png" alt="image-20210330111035917"></p><h2 id="emit，子往父">$emit，子往父</h2><p><img src="/img/image-20210429113217209.png" alt="image-20210429113217209"></p><p>​ 在方法中，子组件抛出事件</p><p><img src="/img/image-20210429101448176.png" alt="image-20210429101448176"></p><p>在父组件里绑定监听</p><p><img src="/img/image-20210428183940688.png" alt="image-20210428183940688"></p><h2 id="中央事件总线，兄弟间">中央事件总线，兄弟间</h2><p><img src="/img/image-20210429113958643.png" alt="image-20210429113958643"></p><p><img src="/img/image-20210429115503571.png" alt="image-20210429115503571"></p><h2 id="slot-插槽">slot 插槽</h2><p>​ 子组件预留插槽，等待父组件传递标签展示内容</p><p><img src="/img/image-20210429163258848.png" alt="image-20210429163258848"></p><h1>Ajax</h1><h2 id="axios">axios</h2><p><img src="/img/image-20210501111756598.png" alt="image-20210501111756598"></p><h1>基本路由</h1><h2 id="定义路由-→-注册路由-→-使用路由">定义路由 → 注册路由 → 使用路由</h2><p>​ 1.在 views 文件夹中创建路由</p><p><img src="/img/image-20210615141023656.png" alt="image-20210615141023656"></p><p>​ 2.在 router 路由器中映射成路由</p><p><img src="/img/image-20210615141119028.png" alt="image-20210615141119028"></p><p>​ 3.在需要使用的组件中写标签 router-link to （导航） 和 router-view （内容展示）</p><p><img src="/img/image-20210615141300786.png" alt="image-20210615141300786"></p><p>​ 4.在 main.js 中需要一次性配置 router</p><p><img src="/img/image-20210615141448875.png" alt="image-20210615141448875"></p><h1>嵌套路由</h1><p><img src="/img/image-20210619152732333.png" alt="image-20210619152732333"></p><h1>向路由组件传递数据</h1><h2 id="方式-1-用-id">方式 1 用 :id</h2><p><img src="/img/image-20210816173931903.png" alt="image-20210816173931903"></p><h2 id="方式-2-类似-props-传递">方式 2 类似 props 传递</h2><p><img src="/img/image-20210816174044073.png" alt="image-20210816174044073"></p><h1>缓存路由组件</h1><p>​ 保持路由组件对象存活，避免重新创建路由组件对象导致数据丢失</p><p><img src="/img/image-20210816175546526.png" alt="image-20210816175546526"></p><h1>编程式路由导航</h1><p>​ 常用前三种</p><p><img src="/img/image-20210817152349108.png" alt="image-20210817152349108"></p><p><img src="/img/image-20210817152847443.png" alt="image-20210817152847443"></p><p><img src="/img/image-20210817152906090.png" alt="image-20210817152906090"></p><p><img src="/img/image-20210817152959447.png" alt="image-20210817152959447"></p><h1>VUEX</h1><p><img src="/img/image-20210819204107697.png" alt="image-20210819204107697"></p><p><img src="/img/image-20210819221802923.png" alt="image-20210819221802923"></p><h2 id="vuex-的基本使用，最简单的-store">vuex 的基本使用，最简单的 store</h2><p><img src="/img/image-20210819190341308.png" alt="image-20210819190341308"></p><h2 id="小型项目无需使用-vuex-的时候，使用简单的-store-模式">小型项目无需使用 vuex 的时候，使用简单的 store 模式</h2><p><img src="/img/image-20210819190732653.png" alt="image-20210819190732653"></p><p><img src="/img/image-20210819190800737.png" alt="image-20210819190800737"></p><p><img src="/img/image-20210819190822214.png" alt="image-20210819190822214"></p><h2 id="store-的常用属性：-state-getters-dispatch-commit">store 的常用属性： state getters dispatch commit</h2><h3 id="getters-的使用">getters 的使用</h3><p><img src="/img/image-20210819203852069.png" alt="image-20210819203852069"></p><h2 id="mapState-mapGetters-mapActions-的使用">mapState mapGetters mapActions 的使用</h2><p>​ 让语法更简洁</p><p><img src="/img/image-20210819220446128.png" alt="image-20210819220446128"></p><p><img src="/img/image-20210819220554738.png" alt="image-20210819220554738"></p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack学习笔记</title>
    <link href="/2020/11/24/webpack/"/>
    <url>/2020/11/24/webpack/</url>
    
    <content type="html"><![CDATA[<h1>webpack：静态模块打包器</h1><p>​ npm init -y （初始化项目，记录依赖） npm i webpack webpack-cli -D</p><p>​ 静态资源（js/json/css/img/less/…）→chunk（块：各种相互依赖的文件）→ 打包（less→css,js→js…）→ bundle（输出）</p><h2 id="webpack-五个核心概念">webpack 五个核心概念</h2><p><img src="/img/image-20210305150256460.png" alt="image-20210305150256460"></p><p><img src="/img/image-20210305150706854.png" alt="image-20210305150706854"></p><p><img src="/img/image-20210305162439514.png" alt="image-20210305162439514"></p><h2 id="打包样式文件：loader，下载-→-使用">打包样式文件：loader，下载 → 使用</h2><h3 id="打包-css">打包 css</h3><p><img src="/img/image-20210307111030416.png" alt="image-20210307111030416"></p><h3 id="打包-less">打包 less</h3><p><img src="/img/image-20210307151303263.png" alt="image-20210307151303263"></p><h2 id="打包-html：通过-html-webpack-plugin">打包 html：通过 html-webpack-plugin</h2><p>​ 与 loader 不同，需要下载 → 引入 → 使用</p><p><img src="/img/image-20210307152626686.png" alt="image-20210307152626686"></p><h2 id="打包图片资源">打包图片资源</h2><p>​ 使用多个 loader 用 use，一个用 loader</p><p>​ url-loader 依赖 file-loader</p><p>​ 处理 url 里的图片：</p><p>​ 图片重命名：options: {name: ‘[hash:10].[ext]’} 取哈希值的前 10 位，取文件原来的扩展名</p><p><img src="/img/image-20210308091903479.png" alt="image-20210308091903479"></p><p>处理 html 里的 img 图片：html-withimg-loader,并且设置 esModule: false</p><p><img src="/img/image-20210308103752111.png" alt="image-20210308103752111"></p><h2 id="打包其它资源">打包其它资源</h2><p><img src="/img/image-20210308111551096.png" alt="image-20210308111551096"></p><h2 id="devServer：开发服务器">devServer：开发服务器</h2><p>​ 安装包：webpack-dev-server 启动指令：npx webpack serve 访问：localhost:3000</p><p><img src="/img/image-20210308112428077.png" alt="image-20210308112428077"></p><h2 id="开发环境配置">开发环境配置</h2><p>​ 见 08 开发环境配置</p><h1>生产环境</h1><h2 id="单独提取-css">单独提取 css</h2><p>​ 安装 mini-css-extract-plugin 插件</p><p>​ <img src="/img/image-20210309110946971.png" alt="image-20210309110946971"></p><p>​ 用该插件替代 style-loader</p><p><img src="/img/image-20210309111018113.png" alt="image-20210309111018113"></p><h2 id="css-兼容性处理">css 兼容性处理</h2><p>​ postcss-loader 和 postcss-preset-env</p><p>​ 在 package.json 中配置 browserslist</p><p>​ process.env.NODE_ENV 配置 node 环境变量，从而加载 development 的兼容性样式</p><p><img src="/img/image-20210309115146427.png" alt="image-20210309115146427"></p><p><img src="/img/image-20210309114335361.png" alt="image-20210309114335361"></p><p><img src="/img/image-20210309131637564.png" alt="image-20210309131637564"></p><h2 id="压缩-css">压缩 css</h2><p>插件：optimize-css-assets-webpack-plugin 引入，使用即可</p><p><img src="/img/image-20210309133153937.png" alt="image-20210309133153937"></p><h2 id="js-语法检查-eslint">js 语法检查 eslint</h2><p>​ 图中 eslint-loader 弃用 改为 eslint-webpack-plugin</p><p><img src="/img/image-20210309140846885.png" alt="image-20210309140846885"></p><h2 id="js-兼容性处理-babel">js 兼容性处理 babel</h2><p>​ 注：@babel/polyfill 替换成 babel-polyfil 无需配置，直接在 index.js 引入即可</p><p>​ core-js 和 babel-polyfill 只能选一个</p><p><img src="/img/image-20210312155645903.png" alt="image-20210312155645903"></p><p>​ 推荐：按需加载</p><p><img src="/img/image-20210312131249166.png" alt="image-20210312131249166"></p><h2 id="压缩-js-和-html">压缩 js 和 html</h2><p>​ mode: production HTML 和 js 都会去除空格和注释，js 还会运行函数，直接将结果进行打包</p><p><img src="/img/image-20210315142733466.png" alt="image-20210315142733466"></p><h2 id="生产环境基本配置">生产环境基本配置</h2><p>​ 见代码</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node学习笔记</title>
    <link href="/2020/10/03/node/"/>
    <url>/2020/10/03/node/</url>
    
    <content type="html"><![CDATA[<h1>node 基本原理</h1><p><img src="/img/image-20201202163918589.png" alt=""></p><p><img src="/img/image-20201202165741414.png" alt=""></p><p><img src="/img/image-20201203111323129.png" alt="image-20201203111323129"></p><h2 id="nodejs-特点">nodejs 特点</h2><p><img src="/img/image-20201203094207673.png" alt="image-20201203094207673"></p><h2 id="事件驱动：">事件驱动：</h2><p><img src="/img/image-20210222093816560.png" alt="image-20210222093816560"></p><p><img src="/img/image-20201203100413186.png" alt=""></p><h1>nodejs 全局变量（可以直接使用，不需要 require）</h1><p><img src="/img/image-20201203110848705.png" alt="image-20201203110848705"></p><h1>buffer</h1><p><img src="/img/image-20210907095757920.png" alt="image-20210907095757920"></p><h1>stream 流</h1><p><img src="/img/image-20210903162426015.png" alt="image-20210903162426015"></p><h2 id="fs-createReadStream-可写流">fs.createReadStream 可写流</h2><p><img src="/img/image-20210904081035773.png" alt="image-20210904081035773"></p><h2 id="fs-createWriteStream-可读流">fs.createWriteStream 可读流</h2><p><img src="/img/image-20210904081126794.png" alt="image-20210904081126794"></p><p><img src="/img/image-20210904081151997.png" alt="image-20210904081151997"></p><h2 id="pipe-管道流">.pipe 管道流</h2><p>​ 将可读流的数据传输到可写流</p><p><img src="/img/image-20210904083849970.png" alt="image-20210904083849970"></p><p><img src="/img/image-20210904083910909.png" alt="image-20210904083910909"></p><h1>链式流 用来操作管道流</h1><h2 id="压缩和解压缩">压缩和解压缩</h2><h2 id="zlib-createGzip">zlib.createGzip</h2><p><img src="/img/image-20210904090828392.png" alt="image-20210904090828392"></p><h2 id="zlib-createGunzip">zlib.createGunzip</h2><p><img src="/img/image-20210904090901515.png" alt="image-20210904090901515"></p><h1>文件写入操作 fs.writeFile()</h1><p><img src="/img/image-20201203110531468.png" alt=""></p><h1>文件读取：fs.readFile() 不传编码默认读取为 buffer</h1><p><img src="/img/image-20201203113717472.png" alt=""></p><h1>绝对路径</h1><p><img src="/img/image-20201203120045386.png" alt="image-20201203120045386"></p><h1>path 路径拼接</h1><p><img src="/img/image-20201203130658873.png" alt="image-20201203130658873"></p><h1>创建文件夹</h1><p><img src="/img/image-20201203160040885.png" alt="image-20201203160040885"></p><h1>http 模块创建最简单的 http 服务</h1><p><img src="/img/image-20201203220844331.png" alt=""></p><h1>根据用户请求路径返回结果：res.url</h1><p><img src="/img/image-20201204143305781.png" alt="image-20201204143305781"></p><h1>根据用户请求路径返回现有的 HTML 文件</h1><p><img src="/img/image-20201204154544423.png" alt="image-20201204154544423"></p><h1>try -catch</h1><p><img src="/img/image-20201208160450594.png" alt="image-20201208160450594"></p><h1>模仿 Apache 服务器</h1><p><img src="/img/image-20201221105744537.png" alt=""></p><p>对于服务器而言，请求的 url 就是一个标识符</p><h1>request（http.IncomingMessage）对象常用 API</h1><p><img src="/img/image-20201210104036265.png" alt="image-20201210104036265"></p><h1>response（http.ServerResponse）常用 API</h1><p>​ ps:如果没有手动调用 res.writeHead（）则系统会隐式的调用（如果有调用 4、5 方法此时相应的设置会被引用，没有则设置默认值）</p><p><img src="/img/image-20201210111116298.png" alt="image-20201210111116298"></p><h1>NPM（node package manager）</h1><p>​ 客户端、代码仓库、网站</p><p><img src="/img/image-20201210114924214.png" alt="image-20201210114924214"></p><h1>模块和包的区别</h1><p><img src="/img/image-20201211141745393.png" alt="image-20201211141745393"></p><h2 id="模块的导入导出">模块的导入导出</h2><p><img src="/img/image-20210222210415889.png" alt="image-20210222210415889"></p><h2 id="package-json-元文件：描述项目自身的文件">package.json(元文件：描述项目自身的文件)</h2><p><img src="/img/image-20201211153437476.png" alt="image-20201211153437476"></p><p><img src="/img/image-20201211154156226.png" alt="image-20201211154156226"></p><h1>url 模块，url.parse()</h1><p><img src="/img/image-20201221100259760.png" alt="image-20201221100259760"></p><p><img src="/img/image-20201221100315632.png" alt="image-20201221100315632"></p><p><img src="/img/image-20201221100223791.png" alt="image-20201221100223791"></p><h2 id="重定向">重定向</h2><p><img src="/img/image-20201221114532427.png" alt="image-20201221114532427"></p><h1>require 加载模块时 同步加载</h1><p><img src="/img/image-20201222140705533.png" alt="image-20201222140705533"></p><h4 id=""></h4><h1><strong>express</strong></h1><h2 id="res-send-与-res-end-的区别">res.send()与 res.end()的区别</h2><p><img src="/img/image-20201223171823855.png" alt="image-20201223171823855"></p><h2 id="Hello-world">Hello world</h2><p><img src="/img/image-20201224130930721.png" alt="image-20201224130930721"></p><h2 id="注册路由-get-use-all-的区别">注册路由 get(), use(), all()的区别</h2><p><img src="/img/image-20201224132014820.png" alt="image-20201224132014820"></p><p>注册路由 正则表达式</p><p><img src="/img/image-20201224133004235.png" alt="image-20201224133004235"></p><p>​ 通过 req.params 获取请求路由中的参数</p><p><img src="/img/image-20201224133634313.png" alt="image-20201224133634313"></p><h2 id="简单模拟-Apache">简单模拟 Apache</h2><p><img src="/img/image-20201224135429120.png" alt="image-20201224135429120"></p><p>response 常用 api</p><p><img src="/img/image-20201229135557689.png" alt="image-20201229135557689"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
